From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: derverdox <mail.ysp@web.de>
Date: Sat, 17 Feb 2024 14:42:06 +0100
Subject: [PATCH] Temp patches


diff --git a/src/main/java/de/verdox/mccreativelab/CraftDataPackInterceptor.java b/src/main/java/de/verdox/mccreativelab/CraftDataPackInterceptor.java
index 39be82b372d5fb8bd17877dfcf35c03a6b3b3bc3..a9f060b3f0e53d1d2ac9b8d9c02014d982b1fd69 100644
--- a/src/main/java/de/verdox/mccreativelab/CraftDataPackInterceptor.java
+++ b/src/main/java/de/verdox/mccreativelab/CraftDataPackInterceptor.java
@@ -2,18 +2,23 @@ package de.verdox.mccreativelab;
 
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParser;
+import com.mojang.logging.LogUtils;
 import de.verdox.mccreativelab.data.DataPackInterceptor;
 import net.kyori.adventure.key.Key;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.IoSupplier;
+import org.apache.commons.io.FilenameUtils;
+import org.slf4j.Logger;
 
 import javax.annotation.Nullable;
 import java.io.*;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
 import java.util.*;
 import java.util.function.Consumer;
 
 public class CraftDataPackInterceptor implements DataPackInterceptor {
+    private static final Logger LOGGER = LogUtils.getLogger();
     private final Set<PackAssetType> excludedTypes = new HashSet<>();
     private final Set<String> stringPatternExcludes = new HashSet<>();
     private final Map<PackAssetType, Set<Key>> exclusions = new HashMap<>();
@@ -53,19 +58,21 @@ public class CraftDataPackInterceptor implements DataPackInterceptor {
 
     @Nullable
     public IoSupplier<InputStream> evaluate(ResourceLocation resourceLocation, Path assetPath, IoSupplier<InputStream> ioSupplier) {
-        if (this.installCallback == null)
-            return ioSupplier;
 
         String assetTypeName = resourceLocation.toString().split("/")[0];
         int indexOfStartKey = assetTypeName.indexOf(":");
         assetTypeName = assetTypeName.substring(indexOfStartKey + 1);
         PackAssetType packAssetType = PackAssetType.getByParentFolder(assetTypeName);
-        Key key = Key.key(resourceLocation.getNamespace(), resourceLocation.getPath());
-        if(packAssetType == null)
+        Key key = Key.key(resourceLocation.getNamespace(), FilenameUtils.removeExtension(resourceLocation.getPath().replace(assetTypeName+"/","")));
+        if(packAssetType == null) {
+            LOGGER.error("Could not determine PackAssetType "+assetTypeName+" from "+resourceLocation);
             return ioSupplier;
+        }
 
-        if(excludedTypes.contains(packAssetType) || stringPatternExcludes.stream().anyMatch(s -> resourceLocation.toString().contains(s)) || (exclusions.containsKey(packAssetType) && exclusions.get(packAssetType).contains(key)))
+        if(excludedTypes.contains(packAssetType) || stringPatternExcludes.stream().anyMatch(s -> resourceLocation.toString().contains(s)) || (exclusions.containsKey(packAssetType) && exclusions.get(packAssetType).contains(key))) {
+            LOGGER.info("Removing "+packAssetType.name()+": "+key);
             return null;
+        }
 
         try (InputStream inputStream = ioSupplier.get()) {
             ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
@@ -95,11 +102,13 @@ public class CraftDataPackInterceptor implements DataPackInterceptor {
                 Map<Key, List<Consumer<DataPackAsset>>> map = modifies.get(packAssetType);
                 if(map.containsKey(key)){
                     List<Consumer<DataPackAsset>> modifiers = map.get(key);
+                    LOGGER.info("Patching "+packAssetType.name()+": "+key);
                     modifiers.forEach(dataPackAssetConsumer -> dataPackAssetConsumer.accept(dataPackAsset));
                 }
             }
 
-            this.installCallback.accept(dataPackAsset);
+            if(this.installCallback != null)
+                this.installCallback.accept(dataPackAsset);
 
             // Hier kannst du das JsonObject nach Belieben manipulieren
             // Zum Beispiel: jsonObject.addProperty("neuesFeld", "Wert");
@@ -109,20 +118,11 @@ public class CraftDataPackInterceptor implements DataPackInterceptor {
 
             // Schlie√üe den ByteArrayOutputStream
             byteArrayOutputStream.close();
-            new IoSupplier<InputStream>() {
-                @Override
-                public InputStream get() throws IOException {
-                    return new ByteArrayInputStream(jsonObject.toString().getBytes("UTF-8"));
-                }
-            };
+            return () -> new ByteArrayInputStream(jsonObject.toString().getBytes(StandardCharsets.UTF_8));
 
         } catch (IOException e) {
-            System.err.println("Error while manipulating DataPack resource installation");
-            e.printStackTrace();
+            LOGGER.error("Error while manipulating DataPack resource installation", e);
             return ioSupplier;
         }
-
-
-        return ioSupplier;
     }
 }
diff --git a/src/main/java/de/verdox/mccreativelab/advancement/CraftAdvancementBuilder.java b/src/main/java/de/verdox/mccreativelab/advancement/CraftAdvancementBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c71e990fc82039a1581ce49572658cf93e351f0
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/advancement/CraftAdvancementBuilder.java
@@ -0,0 +1,5 @@
+package de.verdox.mccreativelab.advancement;
+
+public class CraftAdvancementBuilder {
+
+}
diff --git a/src/main/java/de/verdox/mccreativelab/ai/builder/CraftGoalFactory.java b/src/main/java/de/verdox/mccreativelab/ai/builder/CraftGoalFactory.java
index 81d1727ea968dd5c1316a826972d10e2603f68bb..7110abaac95d29e5ec2ec446de56c7d02c54ba7e 100644
--- a/src/main/java/de/verdox/mccreativelab/ai/builder/CraftGoalFactory.java
+++ b/src/main/java/de/verdox/mccreativelab/ai/builder/CraftGoalFactory.java
@@ -2,6 +2,7 @@ package de.verdox.mccreativelab.ai.builder;
 
 import com.destroystokyo.paper.entity.RangedEntity;
 import com.destroystokyo.paper.entity.ai.VanillaGoal;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
 import io.papermc.paper.adventure.PaperAdventure;
 import net.kyori.adventure.sound.Sound;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -31,6 +32,7 @@ import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.RecipeChoice;
 
 import java.util.function.BooleanSupplier;
+import java.util.function.Function;
 import java.util.function.Predicate;
 
 public class CraftGoalFactory implements GoalFactory {
@@ -80,8 +82,8 @@ public class CraftGoalFactory implements GoalFactory {
     }
 
     @Override
-    public VanillaGoal<Mob> eatBlock(Mob mob, Predicate<BlockState> predicate) {
-        return asGoal(new EatBlockGoal(toNms(mob), predicate));
+    public VanillaGoal<Mob> eatBlock(Mob mob, Function<VanillaRandomSource, Boolean> chanceToEat, Predicate<BlockState> predicate) {
+        return asGoal(new EatBlockGoal(toNms(mob), chanceToEat, predicate));
     }
 
     @Override
@@ -294,7 +296,6 @@ public class CraftGoalFactory implements GoalFactory {
         return asGoal(new ZombieAttackGoal((net.minecraft.world.entity.monster.Zombie) toNms(zombie), speed, pauseWhenMobIdle));
     }
 
-    private Class<? extends net.minecraft.world.entity.PathfinderMob> toNms(World world, EntityType entityType) {
     private Class<? extends net.minecraft.world.entity.LivingEntity> toNms(World world, EntityType entityType) {
         if(entityType.equals(EntityType.PLAYER))
             return Player.class;
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviourUtil.java b/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviourUtil.java
index cfe1847ba91bc914fd51cf210f83b1edf690b495..f52f75900a74dc271b551fd55b456019e18a779b 100644
--- a/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviourUtil.java
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviourUtil.java
@@ -11,6 +11,7 @@ import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
@@ -139,6 +140,22 @@ public class BlockBehaviourUtil extends BehaviourUtil{
             blockBehaviour.onDestroy(new Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ()), drop, breakingEntity != null ? breakingEntity.getBukkitEntity() : null, maxUpdateDepth));
     }
 
+    public boolean growCrop(ItemStack stack, Level world, BlockPos pos, Supplier<Boolean> vanillaLogic) {
+        BlockState state = world.getBlockState(pos);
+        return evaluateBoolean(BlockBehaviour.BLOCK_BEHAVIOUR,
+            getMaterial(state),
+            blockBehaviour -> {
+                world.captureTreeGeneration = false;
+                world.captureBlockStates = false;
+                BehaviourResult.Bool result = blockBehaviour.fertilizeAction(world.getWorld()
+                                                    .getBlockAt(pos.getX(), pos.getY(), pos.getZ()), stack.getBukkitStack());
+                world.capturedBlockStates.clear(); // We do this to prevent bukkit logic since it kills our custom logic
+                return result;
+            },
+            vanillaLogic
+            );
+    }
+
 
     public void onUseCallback(BlockState state, Level world, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) {
         BlockBehaviourUtil.evaluateCallback(BlockBehaviour.BLOCK_BEHAVIOUR, getMaterial(state), blockBehaviour -> {
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviourUtil.java b/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviourUtil.java
index 33b873c6ebddfd5b81c4971064b9ebbcd711cfb4..35abb85b42d088fafddf1179b0254fdece69b78f 100644
--- a/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviourUtil.java
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviourUtil.java
@@ -28,6 +28,7 @@ import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
 
 import javax.annotation.Nullable;
+import java.util.function.Supplier;
 
 public class ItemBehaviourUtil extends BehaviourUtil {
     public static ItemStack finishUsingItem(ItemStack stack, Level world, LivingEntity user) {
@@ -38,6 +39,15 @@ public class ItemBehaviourUtil extends BehaviourUtil {
         );
     }
 
+    public static BlockState placeBlockAction(Player player, BlockPos pos, Level world, ItemStack stack, BlockState state, Supplier<BlockState> vanillaLogic){
+
+        return evaluate(getBehaviour(stack),
+            itemBehaviour -> itemBehaviour.placeBlockAction(stack.getBukkitStack(), ((CraftPlayer) player.getBukkitEntity()), new Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ()), Converter.BlockData.INSTANCE.nmsToBukkitValue(state)),
+            vanillaLogic,
+            Converter.BlockData.INSTANCE
+        );
+    }
+
     public static InteractionResultHolder<ItemStack> use(ItemStack stack, Level world, Player user, InteractionHand hand){
         return evaluate(getBehaviour(stack), itemBehaviour ->
                 itemBehaviour.use(stack.asBukkitMirror(), ((org.bukkit.entity.Player) user.getBukkitEntity()), hand.equals(InteractionHand.MAIN_HAND) ? EquipmentSlot.HAND : EquipmentSlot.OFF_HAND),
diff --git a/src/main/java/de/verdox/mccreativelab/event/EventToPacketFactory.java b/src/main/java/de/verdox/mccreativelab/event/EventToPacketFactory.java
index bed837a02b4239ebb764a01fd542224aad4eb485..2748a943d3508d4f87de536b993bdc7ab30270a8 100644
--- a/src/main/java/de/verdox/mccreativelab/event/EventToPacketFactory.java
+++ b/src/main/java/de/verdox/mccreativelab/event/EventToPacketFactory.java
@@ -83,7 +83,7 @@ public class EventToPacketFactory {
         ClientboundLevelEventPacket clientboundLevelEventPacket = new ClientboundLevelEventPacket(event.getEffect()
                                                                                                        .getId(), new BlockPos(event
             .getSoundLocation().getBlockX(), event.getSoundLocation().getBlockY(), event.getSoundLocation()
-                                                                                        .getBlockZ()), event.getData(), event.isGlobal());
+                                                                                        .getBlockZ()), data, event.isGlobal());
 
         if (event.isGlobal())
             serverLevel.getServer().getPlayerList().broadcastAll(clientboundLevelEventPacket);
diff --git a/src/main/java/de/verdox/mccreativelab/worldgen/ChunkDataUtil.java b/src/main/java/de/verdox/mccreativelab/worldgen/ChunkDataUtil.java
index d133885c10963eb756463d8b5a4ff67d32a2e56d..2589969701eb6be78a47703d26318d8d6f42088f 100644
--- a/src/main/java/de/verdox/mccreativelab/worldgen/ChunkDataUtil.java
+++ b/src/main/java/de/verdox/mccreativelab/worldgen/ChunkDataUtil.java
@@ -15,18 +15,18 @@ public class ChunkDataUtil {
 
     public static void callChunkDataCreateEvent(ServerLevel serverLevel, ChunkAccess chunkAccess, PersistentDataContainer persistentDataContainer) {
         Bukkit.getPluginManager()
-              .callEvent(new ChunkDataCreateEvent(serverLevel.getWorld(), getCraftChunk(chunkAccess), createEventChunkPos(chunkAccess), persistentDataContainer));
+              .callEvent(new ChunkDataCreateEvent(serverLevel.getWorld(), getCraftChunk(serverLevel, chunkAccess, persistentDataContainer), createEventChunkPos(chunkAccess), persistentDataContainer));
         chunkAccess.persistentDataContainer.dirty(true);
     }
 
     public static void callChunkDataLoadEvent(ServerLevel serverLevel, ChunkAccess chunkAccess, PersistentDataContainer persistentDataContainer) {
         Bukkit.getPluginManager().
-              callEvent(new ChunkDataLoadEvent(serverLevel.getWorld(), getCraftChunk(chunkAccess), createEventChunkPos(chunkAccess), persistentDataContainer));
+              callEvent(new ChunkDataLoadEvent(serverLevel.getWorld(), getCraftChunk(serverLevel, chunkAccess, persistentDataContainer), createEventChunkPos(chunkAccess), persistentDataContainer));
     }
 
     public static void callChunkDataSaveEvent(ServerLevel serverLevel, ChunkAccess chunkAccess, PersistentDataContainer persistentDataContainer, boolean unloadingChunk) {
         Bukkit.getPluginManager()
-              .callEvent(new ChunkDataSaveEvent(serverLevel.getWorld(), getCraftChunk(chunkAccess), createEventChunkPos(chunkAccess), persistentDataContainer, unloadingChunk));
+              .callEvent(new ChunkDataSaveEvent(serverLevel.getWorld(), getCraftChunk(serverLevel, chunkAccess, persistentDataContainer), createEventChunkPos(chunkAccess), persistentDataContainer, unloadingChunk));
         chunkAccess.persistentDataContainer.dirty(true);
     }
 
@@ -34,8 +34,8 @@ public class ChunkDataUtil {
         return new ChunkDataEvent.ChunkPos(chunkAccess.locX, chunkAccess.locZ);
     }
 
-    private static CraftChunk getCraftChunk(ChunkAccess chunkAccess) {
-        return chunkAccess instanceof LevelChunk chunk ? new CraftChunk(chunk) : null;
+    private static CraftWorldGenChunk getCraftChunk(ServerLevel serverLevel, ChunkAccess chunkAccess, PersistentDataContainer persistentDataContainer) {
+        return new CraftWorldGenChunk(serverLevel.getWorld(), chunkAccess, persistentDataContainer);
     }
 
 }
diff --git a/src/main/java/de/verdox/mccreativelab/worldgen/CraftWorldGenChunk.java b/src/main/java/de/verdox/mccreativelab/worldgen/CraftWorldGenChunk.java
index ec2f7ba0b735df1a69169699a488b43a7a39c6b1..25a26d86246dac83eb5359628b544e6b8f2d5668 100644
--- a/src/main/java/de/verdox/mccreativelab/worldgen/CraftWorldGenChunk.java
+++ b/src/main/java/de/verdox/mccreativelab/worldgen/CraftWorldGenChunk.java
@@ -2,14 +2,34 @@ package de.verdox.mccreativelab.worldgen;
 
 import net.minecraft.world.level.chunk.ChunkAccess;
 import org.bukkit.Chunk;
+import org.bukkit.ChunkSnapshot;
 import org.bukkit.World;
+import org.bukkit.block.Biome;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+import org.bukkit.metadata.MetadataValue;
 import org.bukkit.persistence.PersistentDataContainer;
+import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
 
-public class CraftWorldGenChunk implements WorldGenChunk{
+import java.util.Collection;
+import java.util.List;
+import java.util.function.Predicate;
+
+public class CraftWorldGenChunk implements WorldGenChunk {
     private final World world;
     private Chunk chunk;
     private ChunkAccess chunkAccess;
+    private PersistentDataContainer persistentDataContainer;
+    private final DummyChunkForMetaDataStore dummyChunkForMetaDataStore = new DummyChunkForMetaDataStore(this);
+    public CraftWorldGenChunk(World world, ChunkAccess chunkAccess, PersistentDataContainer persistentDataContainer) {
+        this.world = world;
+        this.chunkAccess = chunkAccess;
+        this.persistentDataContainer = persistentDataContainer;
+    }
     public CraftWorldGenChunk(World world, ChunkAccess chunkAccess) {
         this.world = world;
         this.chunkAccess = chunkAccess;
@@ -32,6 +52,214 @@ public class CraftWorldGenChunk implements WorldGenChunk{
     }
     @Override
     public @NotNull PersistentDataContainer getPersistentDataContainer() {
-        return chunk != null ? chunk.getPersistentDataContainer() : chunkAccess.persistentDataContainer;
+        return persistentDataContainer != null ? persistentDataContainer : chunk != null && chunk.isLoaded() ? chunk.getPersistentDataContainer() : chunkAccess.persistentDataContainer;
+    }
+
+    public CraftWorld getCraftWorld() {
+        return (CraftWorld) this.getWorld();
+    }
+
+    @Override
+    public void setMetadata(String metadataKey, org.bukkit.metadata.MetadataValue newMetadataValue) {
+        getCraftWorld().chunkMetadataStore.setMetadata(chunk != null ? chunk : dummyChunkForMetaDataStore, metadataKey, newMetadataValue);
+    }
+
+    @Override
+    public java.util.List<org.bukkit.metadata.MetadataValue> getMetadata(String metadataKey) {
+        return getCraftWorld().chunkMetadataStore.getMetadata(chunk != null ? chunk : dummyChunkForMetaDataStore, metadataKey);
+    }
+
+    @Override
+    public boolean hasMetadata(String metadataKey) {
+        return getCraftWorld().chunkMetadataStore.hasMetadata(chunk != null ? chunk : dummyChunkForMetaDataStore, metadataKey);
+    }
+
+    @Override
+    public void removeMetadata(String metadataKey, Plugin owningPlugin) {
+        getCraftWorld().chunkMetadataStore.removeMetadata(chunk != null ? chunk : dummyChunkForMetaDataStore, metadataKey, owningPlugin);
+    }
+
+
+
+    /**
+     * This only implements the methods needed for ChunkMetadataStore to call the disambiguate function
+     * @param craftWorldGenChunk
+     */
+    private record DummyChunkForMetaDataStore(CraftWorldGenChunk craftWorldGenChunk) implements Chunk {
+        @Override
+            public int getX() {
+                return craftWorldGenChunk.getX();
+            }
+
+            @Override
+            public int getZ() {
+                return craftWorldGenChunk.getZ();
+            }
+
+            @Override
+            public @NotNull World getWorld() {
+                return craftWorldGenChunk.getWorld();
+            }
+
+            @Override
+            public @NotNull Block getBlock(int x, int y, int z) {
+                return null;
+            }
+
+            @Override
+            public @NotNull ChunkSnapshot getChunkSnapshot() {
+                return null;
+            }
+
+            @Override
+            public @NotNull ChunkSnapshot getChunkSnapshot(boolean includeMaxblocky, boolean includeBiome, boolean includeBiomeTempRain) {
+                return null;
+            }
+
+            @Override
+            public boolean isEntitiesLoaded() {
+                return false;
+            }
+
+            @Override
+            public @NotNull Entity[] getEntities() {
+                return new Entity[0];
+            }
+
+            @Override
+            public @NotNull BlockState[] getTileEntities(boolean useSnapshot) {
+                return new BlockState[0];
+            }
+
+            @Override
+            public @NotNull Collection<BlockState> getTileEntities(@NotNull Predicate<? super Block> blockPredicate, boolean useSnapshot) {
+                return null;
+            }
+
+            @Override
+            public boolean isGenerated() {
+                return false;
+            }
+
+            @Override
+            public boolean isLoaded() {
+                return false;
+            }
+
+            @Override
+            public boolean load(boolean generate) {
+                return false;
+            }
+
+            @Override
+            public boolean load() {
+                return false;
+            }
+
+            @Override
+            public boolean unload(boolean save) {
+                return false;
+            }
+
+            @Override
+            public boolean unload() {
+                return false;
+            }
+
+            @Override
+            public boolean isSlimeChunk() {
+                return false;
+            }
+
+            @Override
+            public boolean isForceLoaded() {
+                return false;
+            }
+
+            @Override
+            public void setForceLoaded(boolean forced) {
+
+            }
+
+            @Override
+            public boolean addPluginChunkTicket(@NotNull Plugin plugin) {
+                return false;
+            }
+
+            @Override
+            public boolean removePluginChunkTicket(@NotNull Plugin plugin) {
+                return false;
+            }
+
+            @Override
+            public @NotNull Collection<Plugin> getPluginChunkTickets() {
+                return null;
+            }
+
+            @Override
+            public long getInhabitedTime() {
+                return 0;
+            }
+
+            @Override
+            public void setInhabitedTime(long ticks) {
+
+            }
+
+            @Override
+            public boolean contains(@NotNull BlockData block) {
+                return false;
+            }
+
+            @Override
+            public boolean contains(@NotNull Biome biome) {
+                return false;
+            }
+
+            @Override
+            public @NotNull LoadLevel getLoadLevel() {
+                return null;
+            }
+
+            @Override
+            public void setAlwaysTicking(boolean alwaysTicking) {
+
+            }
+
+            @Override
+            public boolean isAlwaysTicking() {
+                return false;
+            }
+
+            @Override
+            public void setMetadata(@NotNull String metadataKey, @NotNull MetadataValue newMetadataValue) {
+
+            }
+
+            @Override
+            public @NotNull List<MetadataValue> getMetadata(@NotNull String metadataKey) {
+                return null;
+            }
+
+            @Override
+            public boolean hasMetadata(@NotNull String metadataKey) {
+                return false;
+            }
+
+            @Override
+            public void removeMetadata(@NotNull String metadataKey, @NotNull Plugin owningPlugin) {
+
+            }
+
+            @Override
+            public @NotNull PersistentDataContainer getPersistentDataContainer() {
+                return craftWorldGenChunk.getPersistentDataContainer();
+            }
+        }
+
+    @Override
+    public Chunk toChunk() {
+        if(chunk != null) return chunk;
+        return WorldGenChunk.super.toChunk();
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/EatBlockGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
index 2c58f82ea5b02c520e8d86a69f9a424d3247e74e..cb9e619335092c25f3859372649f4d50f715ed6e 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
@@ -1,8 +1,11 @@
 package net.minecraft.world.entity.ai.goal;
 
 import java.util.EnumSet;
+import java.util.function.Function;
 import java.util.function.Predicate;
 
+import de.verdox.mccreativelab.random.CraftVanillaRandomSource;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.GameRules;
@@ -23,11 +26,13 @@ public class EatBlockGoal extends Goal {
     private final Mob mob;
     private final Level level;
     private int eatAnimationTick;
-    private Predicate<org.bukkit.block.BlockState> bukkitBlockStatePredicate;
+    private final Function<VanillaRandomSource, Boolean> chanceToEat;
+    private final Predicate<org.bukkit.block.BlockState> bukkitBlockStatePredicate;
 
-    public EatBlockGoal(Mob mob, Predicate<org.bukkit.block.BlockState> bukkitBlockStatePredicate) {
+    public EatBlockGoal(Mob mob, Function<VanillaRandomSource, Boolean> chanceToEat, Predicate<org.bukkit.block.BlockState> bukkitBlockStatePredicate) {
         this.mob = mob;
         this.level = mob.level();
+        this.chanceToEat = chanceToEat;
         this.bukkitBlockStatePredicate = bukkitBlockStatePredicate;
         this.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.LOOK, Goal.Flag.JUMP));
     }
@@ -36,6 +41,7 @@ public class EatBlockGoal extends Goal {
         this.mob = mob;
         this.level = mob.level();
         this.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.LOOK, Goal.Flag.JUMP));
+        this.chanceToEat = vanillaRandomSource -> this.mob.getRandom().nextInt(this.mob.isBaby() ? 50 : 1000) != 0;
         this.bukkitBlockStatePredicate = blockState -> IS_TALL_GRASS.test(((org.bukkit.craftbukkit.block.data.CraftBlockData) blockState.getBlockData()).getState());
     }
 
@@ -46,7 +52,7 @@ public class EatBlockGoal extends Goal {
             return false;
         }
         // Paper end
-        if (this.mob.getRandom().nextInt(this.mob.isBaby() ? 50 : 1000) != 0) {
+        if (!this.chanceToEat.apply(new CraftVanillaRandomSource(this.mob.getRandom()))) {
             return false;
         } else {
             BlockPos blockposition = this.mob.blockPosition();
diff --git a/src/main/java/net/minecraft/world/item/BlockItem.java b/src/main/java/net/minecraft/world/item/BlockItem.java
index 9012d635afe4445f60d2e2cf4ff2cbe26bdc372c..92006a81a421d964fad12383058660a9b8d42d8b 100644
--- a/src/main/java/net/minecraft/world/item/BlockItem.java
+++ b/src/main/java/net/minecraft/world/item/BlockItem.java
@@ -95,7 +95,7 @@ public class BlockItem extends Item {
                     BlockState iblockdata1 = world.getBlockState(blockposition);
 
                     if (iblockdata1.is(iblockdata.getBlock())) {
-                        iblockdata1 = this.updateBlockStateFromTag(blockposition, world, itemstack, iblockdata1);
+                        iblockdata1 = this.updateBlockStateFromTag(entityhuman, blockposition, world, itemstack, iblockdata1);
                         // Paper start - reset block on exception
                         try {
                         this.updateCustomBlockEntityTag(blockposition, world, entityhuman, itemstack, iblockdata1);
@@ -122,6 +122,7 @@ public class BlockItem extends Item {
                                 return InteractionResult.FAIL;
                             }
                         }
+
                         // CraftBukkit end
                         if (entityhuman instanceof ServerPlayer) {
                             CriteriaTriggers.PLACED_BLOCK.trigger((ServerPlayer) entityhuman, blockposition, itemstack);
@@ -163,7 +164,7 @@ public class BlockItem extends Item {
         return iblockdata != null && this.canPlace(context, iblockdata) ? iblockdata : null;
     }
 
-    private BlockState updateBlockStateFromTag(BlockPos pos, Level world, ItemStack stack, BlockState state) {
+    private BlockState updateBlockStateFromTag(Player player, BlockPos pos, Level world, ItemStack stack, BlockState state) {
         BlockState iblockdata1 = state;
         CompoundTag nbttagcompound = stack.getTag();
 
@@ -173,11 +174,12 @@ public class BlockItem extends Item {
             iblockdata1 = BlockItem.getBlockState(iblockdata1, nbttagcompound1);
         }
 
-        if (iblockdata1 != state) {
-            world.setBlock(pos, iblockdata1, 2);
-        }
-
-        return iblockdata1;
+        final BlockState finalState = iblockdata1;
+        return de.verdox.mccreativelab.behaviour.ItemBehaviourUtil.placeBlockAction(player, pos, world, stack, state, () -> {
+            if (finalState != state)
+                world.setBlock(pos, finalState, 2);
+            return finalState;
+        });
     }
 
     public static BlockState getBlockState(BlockState iblockdata, CompoundTag nbttagcompound1) {
diff --git a/src/main/java/net/minecraft/world/item/BoneMealItem.java b/src/main/java/net/minecraft/world/item/BoneMealItem.java
index 4bc5c7a68f5d2122864d30eee97d2550a73398f9..004664528dc40445f6c1ff85092ed4606ff8e75c 100644
--- a/src/main/java/net/minecraft/world/item/BoneMealItem.java
+++ b/src/main/java/net/minecraft/world/item/BoneMealItem.java
@@ -69,12 +69,12 @@ public class BoneMealItem extends Item {
     }
 
     public static boolean growCrop(ItemStack stack, Level world, BlockPos pos) {
+        return de.verdox.mccreativelab.behaviour.BlockBehaviourUtil.INSTANCE.growCrop(stack, world, pos, () -> { // MCCreativeLab - Add BlockBehaviour
         BlockState iblockdata = world.getBlockState(pos);
         Block block = iblockdata.getBlock();
 
         if (block instanceof BonemealableBlock) {
             BonemealableBlock iblockfragileplantelement = (BonemealableBlock) block;
-
             if (iblockfragileplantelement.isValidBonemealTarget(world, pos, iblockdata)) {
                 if (world instanceof ServerLevel) {
                     if (iblockfragileplantelement.isBonemealSuccess(world, world.random, pos, iblockdata)) {
@@ -89,6 +89,7 @@ public class BoneMealItem extends Item {
         }
 
         return false;
+        }); // MCCreativeLab - Add BlockBehaviour
     }
 
     public static boolean growWaterPlant(ItemStack stack, Level world, BlockPos blockPos, @Nullable Direction facing) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index ba9169e15ba0ef4e4fdcd0eb4e3e0bf26692bb25..4775bb2ca9ed2458cafe50001150ac51262c7bcc 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -72,7 +72,7 @@ public final class CraftItemStack extends ItemStack {
         if (original.hasItemMeta()) {
             CraftItemStack.setItemMeta(stack, original.getItemMeta());
         }
-        stack.itemBehaviour = original.getItemBehaviour(); // MCCLab - Add ItemBehaviour as instance to this specific Item Stack
+        stack.itemBehaviour = original.getDefinedItemBehaviour(); // MCCLab - Add ItemBehaviour as instance to this specific Item Stack
         return stack;
     }
     // Paper start
@@ -114,7 +114,7 @@ public final class CraftItemStack extends ItemStack {
         if (original instanceof CraftItemStack) {
             CraftItemStack stack = (CraftItemStack) original;
             CraftItemStack newStack = new CraftItemStack(stack.handle == null ? null : stack.handle.copy());
-            newStack.setItemBehaviour(stack.getItemBehaviour());
+            newStack.setItemBehaviour(stack.getDefinedItemBehaviour());
             return newStack;
         }
         return new CraftItemStack(original);
@@ -139,7 +139,7 @@ public final class CraftItemStack extends ItemStack {
 
     private CraftItemStack(ItemStack item) {
         this(item.getType(), item.getAmount(), item.getDurability(), item.hasItemMeta() ? item.getItemMeta() : null);
-        this.setItemBehaviour(item.getItemBehaviour()); // MCCLab - Add ItemBehaviour as instance to this specific Item Stack
+        this.setItemBehaviour(item.getDefinedItemBehaviour()); // MCCLab - Add ItemBehaviour as instance to this specific Item Stack
     }
 
     private CraftItemStack(Material type, int amount, short durability, ItemMeta itemMeta) {
diff --git a/src/main/java/org/bukkit/craftbukkit/metadata/ChunkMetadataStore.java b/src/main/java/org/bukkit/craftbukkit/metadata/ChunkMetadataStore.java
index 5308a686ff6f9a23c9f4faf627a50335e99f59b6..36067e6d20633f68ad68f6941c23d863e6ac9f1e 100644
--- a/src/main/java/org/bukkit/craftbukkit/metadata/ChunkMetadataStore.java
+++ b/src/main/java/org/bukkit/craftbukkit/metadata/ChunkMetadataStore.java
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit.metadata;
 
 import com.google.common.base.Preconditions;
+import de.verdox.mccreativelab.worldgen.WorldGenChunk;
 import org.bukkit.Chunk;
 import org.bukkit.World;
 import org.bukkit.metadata.MetadataStore;
@@ -13,7 +14,7 @@ import java.util.List;
 /**
  * A ChunkMetadataStore stores metadata values for {@link Chunk} objects.
  */
-public class ChunkMetadataStore extends MetadataStoreBase<Chunk> implements MetadataStore<Chunk> {
+public class ChunkMetadataStore extends MetadataStoreBase<WorldGenChunk> implements MetadataStore<WorldGenChunk> {
 
     private final World owningWorld;
     /**
@@ -25,58 +26,58 @@ public class ChunkMetadataStore extends MetadataStoreBase<Chunk> implements Meta
     }
 
     /**
-     * Generates a unique metadata key for a {@link Chunk} object based on its coordinates in the world.
+     * Generates a unique metadata key for a {@link WorldGenChunk} object based on its coordinates in the world.
      * @param chunk the chunk
      * @param metadataKey The name identifying the metadata value
      * @return a unique metadata key
      * @see MetadataStoreBase#disambiguate(Object, String)
      */
     @Override
-    protected String disambiguate(Chunk chunk, String metadataKey) {
+    protected String disambiguate(WorldGenChunk chunk, String metadataKey) {
         return chunk.getChunkKey() + ":" + metadataKey;
     }
 
 
     /**
-     * Retrieves the metadata for a {@link Chunk}, ensuring the chunk being asked for actually belongs to this ChunkMetadataStore's
+     * Retrieves the metadata for a {@link WorldGenChunk}, ensuring the chunk being asked for actually belongs to this ChunkMetadataStore's
      * owning world.
      * @see MetadataStoreBase#getMetadata(Object, String)
      */
     @Override
-    public List<MetadataValue> getMetadata(Chunk chunk, String metadataKey) {
+    public List<MetadataValue> getMetadata(WorldGenChunk chunk, String metadataKey) {
         Preconditions.checkArgument(chunk.getWorld() == this.owningWorld, "Chunk does not belong to world %s", this.owningWorld.getName());
         return super.getMetadata(chunk, metadataKey);
     }
 
     /**
-     * Tests to see if a metadata value has been added to a {@link Chunk}, ensuring the chunk being interrogated belongs
+     * Tests to see if a metadata value has been added to a {@link WorldGenChunk}, ensuring the chunk being interrogated belongs
      * to this ChunkMetadataStore's owning world.
      * @see MetadataStoreBase#hasMetadata(Object, String)
      */
     @Override
-    public boolean hasMetadata(Chunk chunk, String metadataKey) {
+    public boolean hasMetadata(WorldGenChunk chunk, String metadataKey) {
         Preconditions.checkArgument(chunk.getWorld() == this.owningWorld, "Chunk does not belong to world %s", this.owningWorld.getName());
         return super.hasMetadata(chunk, metadataKey);
     }
 
     /**
-     * Removes metadata from from a {@link Chunk} belonging to a given {@link Plugin}, ensuring the chunk being deleted from belongs
+     * Removes metadata from from a {@link WorldGenChunk} belonging to a given {@link Plugin}, ensuring the chunk being deleted from belongs
      * to this ChunkMetadataStore's owning world.
      * @see MetadataStoreBase#removeMetadata(Object, String, org.bukkit.plugin.Plugin)
      */
     @Override
-    public void removeMetadata(Chunk chunk, String metadataKey, Plugin owningPlugin) {
+    public void removeMetadata(WorldGenChunk chunk, String metadataKey, Plugin owningPlugin) {
         Preconditions.checkArgument(chunk.getWorld() == this.owningWorld, "Chunk does not belong to world %s", this.owningWorld.getName());
         super.removeMetadata(chunk, metadataKey, owningPlugin);
     }
 
     /**
-     * Sets or overwrites a metadata value on a {@link Chunk} from a given {@link Plugin}, ensuring the target chunk belongs
+     * Sets or overwrites a metadata value on a {@link WorldGenChunk} from a given {@link Plugin}, ensuring the target chunk belongs
      * to this ChunkMetadataStore's owning world.
      * @see MetadataStoreBase#setMetadata(Object, String, org.bukkit.metadata.MetadataValue)
      */
     @Override
-    public void setMetadata(Chunk chunk, String metadataKey, MetadataValue newMetadataValue) {
+    public void setMetadata(WorldGenChunk chunk, String metadataKey, MetadataValue newMetadataValue) {
         Preconditions.checkArgument(chunk.getWorld() == this.owningWorld, "Chunk does not belong to world %s", this.owningWorld.getName());
         super.setMetadata(chunk, metadataKey, newMetadataValue);
     }
