From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: derverdox <mail.ysp@web.de>
Date: Wed, 17 Jan 2024 00:15:09 +0100
Subject: [PATCH] Temp patch


diff --git a/src/main/java/de/verdox/mccreativelab/CraftVanillaPackGenerator.java b/src/main/java/de/verdox/mccreativelab/CraftVanillaPackGenerator.java
index 2c447c25ae2ed5aa0982620f11a4890326d658ec..d1ae01db549ceed189acb2648619e0cc54bb2695 100644
--- a/src/main/java/de/verdox/mccreativelab/CraftVanillaPackGenerator.java
+++ b/src/main/java/de/verdox/mccreativelab/CraftVanillaPackGenerator.java
@@ -1,94 +1,136 @@
 package de.verdox.mccreativelab;
 
 import de.verdox.mccreativelab.data.DataPackInterceptor;
-import net.minecraft.data.Main;
+import net.kyori.adventure.key.Key;
+import net.minecraft.SharedConstants;
+import net.minecraft.server.packs.PackType;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.FilenameUtils;
 
 import java.io.*;
+import java.net.URI;
 import java.net.URISyntaxException;
+import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.util.LinkedList;
-import java.util.List;
+import java.nio.file.StandardCopyOption;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
 
 public class CraftVanillaPackGenerator implements VanillaPackGenerator {
-    private boolean includeServerPack;
-    private boolean includeClientPack;
-    private boolean includeDevTools;
-    private boolean includeAll;
+    private final Set<PackAssetType> excludedTypes = new HashSet<>();
+    private final Set<String> stringPatternExcludes = new HashSet<>();
+    private final Map<PackAssetType, Set<Key>> exclusions = new HashMap<>();
+    private Consumer<DataPackAsset> installCallback;
 
     @Override
-    public VanillaPackGenerator includeServerPack() {
-        includeServerPack = true;
+    public VanillaPackGenerator exclude(String pathContains) {
+        stringPatternExcludes.add(pathContains);
         return this;
     }
 
     @Override
-    public VanillaPackGenerator includeClientPack() {
-        includeClientPack = true;
+    public VanillaPackGenerator exclude(PackAssetType packAssetType) {
+        excludedTypes.add(packAssetType);
         return this;
     }
 
     @Override
-    public VanillaPackGenerator includeDevelopmentTools() {
-        includeDevTools = true;
+    public VanillaPackGenerator exclude(PackAssetType packAssetType, Key key) {
+        exclusions.computeIfAbsent(packAssetType, packAssetType1 -> new HashSet<>()).add(key);
         return this;
     }
 
     @Override
-    public VanillaPackGenerator includeAll() {
-        includeAll = true;
+    public VanillaPackGenerator onInstall(Consumer<DataPackAsset> installCallback) {
+        this.installCallback = installCallback;
         return this;
     }
 
+    private void buildMCMeta(File file) throws IOException {
+        file.mkdirs();
+        File mcMeta = new File(file, "pack.mcmeta");
+        mcMeta.createNewFile();
+        com.google.common.io.Files.write("{\n"
+            + "    \"pack\": {\n"
+            + "        \"description\": \"Data pack for resources provided by MCCreativeLabs\",\n"
+            + "        \"pack_format\": " + SharedConstants.getCurrentVersion().getPackVersion(PackType.SERVER_DATA) + "\n"
+            + "    }\n"
+            + "}\n", mcMeta, com.google.common.base.Charsets.UTF_8);
+    }
+
     @Override
     public void buildTo(File file) throws IOException {
-        List<String> arguments = new LinkedList<>();
-        if(includeAll)
-            arguments.add("--all");
-        else {
-            if(includeServerPack) arguments.add("--server");
-            if(includeClientPack) arguments.add("--client");
-            if(includeDevTools) arguments.add("--dev");
-        }
-        arguments.add("--output");
-        arguments.add(file.getAbsolutePath());
-
-        Main.main(arguments.toArray(String[]::new));
-
-/*        System.out.println("Running: "+Main.class+" generator in ");
-        ProcessBuilder processBuilder = new ProcessBuilder("java", "-cp", ".", Main.class.getName());
-        processBuilder.command().addAll(arguments);
-        // Leite die Ausgabe und Fehlerausgabe des Prozesses zur Konsole des aufrufenden Programms um
-        processBuilder.redirectOutput(ProcessBuilder.Redirect.INHERIT);
-        processBuilder.redirectError(ProcessBuilder.Redirect.INHERIT);
-
-        Process process = processBuilder.start();
-        // Lese die Ausgabe des Prozesses
-        redirectOutputToConsole(process.getInputStream());
-        redirectOutputToConsole(process.getErrorStream());
-        try {
-            int exitCode = process.waitFor();
-            if(exitCode == 0)
-                System.out.println("Successfully built pack");
-            else
-                System.err.println("Could not build pack "+process);
-        } catch (InterruptedException e) {
-            System.err.print("Error while building pack");
-            e.printStackTrace();
-        }*/
-    }
+        FileUtils.deleteDirectory(file);
+        buildMCMeta(file);
+        List<String> dataPackEntries = new LinkedList<>();
+        dataPackEntries.add("/data/minecraft/worldgen/noise_settings/amplified.json");
+        dataPackEntries.add("/data/minecraft/worldgen/noise_settings/caves.json");
+        dataPackEntries.add("/data/minecraft/worldgen/noise_settings/large_biomes.json");
+        dataPackEntries.add("/data/minecraft/worldgen/noise_settings/nether.json");
+        dataPackEntries.add("/data/minecraft/worldgen/noise_settings/overworld.json");
+
+        findDataPackResources("/data/minecraft", dataPackEntries);
+
+        dataPackEntries.stream().parallel().forEach(resourceEntry -> {
+            if(stringPatternExcludes.stream().anyMatch(resourceEntry::contains))
+                return;
+
+            String[] pathSplit = resourceEntry.split("/");
+
+            PackAssetType packAssetType = PackAssetType.getByParentFolder(pathSplit[3]);
+            if (packAssetType == null)
+                return;
+
+            if(excludedTypes.contains(packAssetType))
+                return;
+
 
-    // Methode zum Umleiten der Ausgabe des Prozesses zur Konsole des aufrufenden Programms
-    private static void redirectOutputToConsole(InputStream inputStream) {
-        new Thread(() -> {
-            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
-                String line;
-                while ((line = reader.readLine()) != null) {
-                    System.err.println(line);
+            String rest = resourceEntry.replace("/data/minecraft/" + packAssetType.getParentFolder(), "");
+            rest = FilenameUtils.removeExtension(rest);
+            Key key = Key.key("minecraft", rest);
+
+            if(exclusions.containsKey(packAssetType) && exclusions.get(packAssetType).contains(key))
+                return;
+
+            Path finalPath = Path.of(file.toPath()+resourceEntry);
+            finalPath.getParent().toFile().mkdirs();
+            try {
+                Files.copy(Objects.requireNonNull(CraftVanillaPackGenerator.class.getResourceAsStream(resourceEntry)), finalPath, StandardCopyOption.REPLACE_EXISTING);
+                if(installCallback != null) {
+                    DataPackAsset dataPackAsset = new DataPackAsset(packAssetType, key, FilenameUtils.getExtension(String.valueOf(finalPath)), finalPath.toFile());
+                    installCallback.accept(dataPackAsset);
                 }
             } catch (IOException e) {
                 e.printStackTrace();
             }
-        }).start();
+        });
+    }
+
+    public void findDataPackResources(String path, List<String> output) throws IOException {
+        try {
+            URI uri = CraftVanillaPackGenerator.class.getResource(path).toURI();
+
+            Path dirPath = Paths.get(uri);
+            try (Stream<Path> stream = Files.list(dirPath)) {
+                stream.forEach(resourcePath -> {
+
+                    String extension = FilenameUtils.getExtension(resourcePath.getFileName().toString());
+
+                    if (extension.isEmpty()) {
+                        try {
+                            findDataPackResources(String.valueOf(resourcePath), output);
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                        }
+                    } else
+                        output.add(resourcePath.toString());
+                });
+            }
+
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
     }
 }
