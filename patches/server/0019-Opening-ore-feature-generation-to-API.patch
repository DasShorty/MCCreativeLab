From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: derverdox <lukasjonsson@outlook.de>
Date: Sat, 18 Nov 2023 14:16:10 +0100
Subject: [PATCH] Opening ore feature generation to API


diff --git a/src/main/java/net/minecraft/world/level/chunk/BulkSectionAccess.java b/src/main/java/net/minecraft/world/level/chunk/BulkSectionAccess.java
index da12d1f274844cbd874f58cc802b6904d9061f72..85d8ecfdb4cda6e81559b0a4f7e443e9b8db4337 100644
--- a/src/main/java/net/minecraft/world/level/chunk/BulkSectionAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/BulkSectionAccess.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.chunk;
 
+import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import javax.annotation.Nullable;
@@ -60,4 +61,29 @@ public class BulkSectionAccess implements AutoCloseable {
         }
 
     }
+
+
+    // MCCLab - start
+    @Nullable private ChunkAccess lastChunkAccess;
+    @Nullable
+    public Pair<LevelChunkSection, ChunkAccess> getSectionAndChunkAccess(BlockPos pos) {
+        int i = this.level.getSectionIndex(pos.getY());
+        if (i >= 0 && i < this.level.getSectionsCount()) {
+            long l = SectionPos.asLong(pos);
+            if (this.lastSection == null || this.lastSectionKey != l) {
+                this.lastSection = this.acquiredSections.computeIfAbsent(l, (lx) -> {
+                    ChunkAccess chunkAccess = this.level.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()));
+                    LevelChunkSection levelChunkSection = chunkAccess.getSection(i);
+                    levelChunkSection.acquire();
+                    this.lastChunkAccess = chunkAccess;
+                    return levelChunkSection;
+                });
+                this.lastSectionKey = l;
+            }
+            return Pair.of(this.lastSection, this.lastChunkAccess);
+        } else {
+            return null;
+        }
+    }
+    // MCCLab - end
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
index 4be60b8d321d8f8cdd97deee16f4b42e428e57cf..d432c2aad11b795a5f2a70f9bbf8a6b19d22302e 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
@@ -3,6 +3,9 @@ package net.minecraft.world.level.levelgen.feature;
 import com.mojang.serialization.Codec;
 import java.util.BitSet;
 import java.util.function.Function;
+
+import de.verdox.mccreativelab.behaviour.WorldGenerationBehaviour;
+import de.verdox.mccreativelab.worldgen.WorldGenerationCallbackUtil;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.Mth;
@@ -10,6 +13,7 @@ import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.WorldGenLevel;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.BulkSectionAccess;
+import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration;
@@ -120,7 +124,18 @@ public class OreFeature extends Feature<OreConfiguration> {
                                                 bitSet.set(am);
                                                 mutableBlockPos.set(ag, ai, ak);
                                                 if (world.ensureCanWrite(mutableBlockPos)) {
-                                                    LevelChunkSection levelChunkSection = bulkSectionAccess.getSection(mutableBlockPos);
+                                                    // MCCLab - start
+                                                    var pair = bulkSectionAccess.getSectionAndChunkAccess(mutableBlockPos);
+                                                    LevelChunkSection levelChunkSection;
+                                                    ChunkAccess chunkAccess = null;
+                                                    if (pair != null) {
+                                                        levelChunkSection = pair.getFirst();
+                                                        chunkAccess = pair.getSecond();
+                                                    }
+                                                    else
+                                                        levelChunkSection = bulkSectionAccess.getSection(mutableBlockPos);
+                                                    //LevelChunkSection levelChunkSection = bulkSectionAccess.getSection(mutableBlockPos);
+                                                    // MCCLab - end
                                                     if (levelChunkSection != null) {
                                                         int an = SectionPos.sectionRelative(ag);
                                                         int ao = SectionPos.sectionRelative(ai);
@@ -130,6 +145,10 @@ public class OreFeature extends Feature<OreConfiguration> {
                                                         for(OreConfiguration.TargetBlockState targetBlockState : config.targetStates) {
                                                             if (canPlaceOre(blockState, bulkSectionAccess::getBlockState, random, config, targetBlockState, mutableBlockPos)) {
                                                                 levelChunkSection.setBlockState(an, ao, ap, targetBlockState.state, false);
+                                                                // MCCLab - start
+                                                                if(chunkAccess != null)
+                                                                    WorldGenerationCallbackUtil.executeWorldGenCallbacks(WorldGenerationBehaviour.FeatureType.ORE_FEATURE, world, new BlockPos(an, ao, ap), targetBlockState.state, chunkAccess);
+                                                                // MCCLab - end
                                                                 ++i;
                                                                 break;
                                                             }
