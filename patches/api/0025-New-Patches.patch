From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: derverdox <mail.ysp@web.de>
Date: Fri, 5 Jan 2024 21:11:40 +0100
Subject: [PATCH] New Patches


diff --git a/src/main/java/de/verdox/mccreativelab/CustomBehaviour.java b/src/main/java/de/verdox/mccreativelab/CustomBehaviour.java
index 2f9981a67d72f575fb2ac37b8b6c2bde4d0733ed..65f0b720ca3cca54440f90b0f6e26f444396cd0b 100644
--- a/src/main/java/de/verdox/mccreativelab/CustomBehaviour.java
+++ b/src/main/java/de/verdox/mccreativelab/CustomBehaviour.java
@@ -19,6 +19,10 @@ public class CustomBehaviour<T> {
         this.key = key;
     }
 
+    public String getKey() {
+        return key;
+    }
+
     /**
      * Used to set a new behaviour.
      * @param behaviour The new implementation
diff --git a/src/main/java/de/verdox/mccreativelab/InteractionResult.java b/src/main/java/de/verdox/mccreativelab/InteractionResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..0daf40262de8269c3dece903bb8f16519da7ed46
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/InteractionResult.java
@@ -0,0 +1,9 @@
+package de.verdox.mccreativelab;
+
+public enum InteractionResult {
+    SUCCESS,
+    CONSUME,
+    CONSUME_PARTIAL,
+    PASS,
+    FAIL;
+}
diff --git a/src/main/java/de/verdox/mccreativelab/MultiCustomBehaviour.java b/src/main/java/de/verdox/mccreativelab/MultiCustomBehaviour.java
index 5db6debc33b781afff966bfc86db11d5b17273da..f3f6272c3e6a56a1ead0ea8484a077ac9d7d21cb 100644
--- a/src/main/java/de/verdox/mccreativelab/MultiCustomBehaviour.java
+++ b/src/main/java/de/verdox/mccreativelab/MultiCustomBehaviour.java
@@ -17,6 +17,10 @@ public class MultiCustomBehaviour<K, T> {
         this.key = key;
     }
 
+    public String getKey() {
+        return key;
+    }
+
     /**
      * Used to set a new behaviour.
      *
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/BehaviourResult.java b/src/main/java/de/verdox/mccreativelab/behaviour/BehaviourResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..adfef7680d03193d829e8aedf17a97e2d66b56e1
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/BehaviourResult.java
@@ -0,0 +1,132 @@
+package de.verdox.mccreativelab.behaviour;
+
+import java.util.function.Supplier;
+
+/**
+ * @param <T> The actual return value of a behaviour that was run.
+ * @param <R> The Result Type
+ */
+public abstract class BehaviourResult<T, R extends Enum<?>> {
+    private final T value;
+    private final R result;
+
+    BehaviourResult(T value, R result) {
+        this.value = value;
+        this.result = result;
+    }
+
+    protected T getValue() {
+        return value;
+    }
+
+    protected R getResult() {
+        return result;
+    }
+
+    protected abstract T evaluateReturnValue(Supplier<T> vanillaLogic);
+    protected abstract boolean replaceVanillaLogic();
+
+    public static class Callback extends BehaviourResult<java.lang.Void, Callback.Type> {
+        public static final Callback DEFAULT_INSTANCE = new Callback();
+
+        Callback() {
+            super(null, Type.NONE);
+        }
+
+        @Override
+        protected java.lang.Void evaluateReturnValue(Supplier<java.lang.Void> vanillaLogic) {
+            return null;
+        }
+
+        @Override
+        protected boolean replaceVanillaLogic() {
+            return false;
+        }
+
+        public enum Type {
+            NONE,
+        }
+    }
+
+    public static class Void extends BehaviourResult<java.lang.Void, Void.Type> {
+        public static final Void DEFAULT_INSTANCE = new Void(Void.Type.USE_VANILLA);
+
+        public Void(Type result) {
+            super(null, result);
+        }
+
+        public boolean replaceVanillaLogic() {
+            return Type.REPLACE_VANILLA.equals(getResult());
+        }
+
+        @Override
+        protected java.lang.Void evaluateReturnValue(Supplier<java.lang.Void> vanillaLogic) {
+            if (!Type.REPLACE_VANILLA.equals(getResult()))
+                return vanillaLogic.get();
+            else
+                return getValue();
+        }
+
+        public enum Type {
+            REPLACE_VANILLA,
+            USE_VANILLA
+        }
+    }
+
+    public static class Bool extends BehaviourResult<Boolean, Bool.Type> {
+        public static final Bool DEFAULT_INSTANCE = new Bool(false, Type.ONLY_VANILLA);
+
+        public Bool(Boolean value, Type result) {
+            super(value, result);
+        }
+
+        @Override
+        protected Boolean evaluateReturnValue(Supplier<Boolean> vanillaLogic) {
+            return switch (getResult()) {
+                case AND -> vanillaLogic.get() && getValue();
+                case OR -> vanillaLogic.get() || getValue();
+                case XOR -> vanillaLogic.get() ^ getValue();
+                case REPLACE_VANILLA -> getValue();
+                case ONLY_VANILLA -> vanillaLogic.get();
+            };
+        }
+
+        @Override
+        protected boolean replaceVanillaLogic() {
+            return Bool.Type.REPLACE_VANILLA.equals(getResult());
+        }
+        public enum Type {
+            AND,
+            OR,
+            XOR,
+            REPLACE_VANILLA,
+            ONLY_VANILLA,
+        }
+    }
+
+    public static class Object<T> extends BehaviourResult<T, Object.Type> {
+        public static final Object DEFAULT_INSTANCE = new Object(null, Type.USE_VANILLA);
+
+        public Object(T value, Type result) {
+            super(value, result);
+        }
+
+        @Override
+        protected T evaluateReturnValue(Supplier<T> vanillaLogic) {
+            return switch (getResult()) {
+                case REPLACE_VANILLA -> getValue();
+                case USE_VANILLA -> vanillaLogic.get();
+            };
+        }
+
+        @Override
+        protected boolean replaceVanillaLogic() {
+            return Object.Type.REPLACE_VANILLA.equals(getResult());
+        }
+
+        public enum Type {
+            REPLACE_VANILLA,
+            USE_VANILLA
+        }
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..db69e6d95c2537309b62d1a898df2c5b11b003d1
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviour.java
@@ -0,0 +1,214 @@
+package de.verdox.mccreativelab.behaviour;
+
+import de.verdox.mccreativelab.InteractionResult;
+import de.verdox.mccreativelab.MultiCustomBehaviour;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.util.RayTraceResult;
+
+public interface BlockBehaviour {
+    MultiCustomBehaviour<Material, BlockBehaviour> BLOCK_BEHAVIOUR = new MultiCustomBehaviour<>("MCCLab - BlockBehaviour");
+
+    /**
+     * This method is called to get the explosion resistance of a block
+     *
+     * @param block     The block
+     * @param blockData The blockData of the block
+     * @return float result
+     */
+    default BehaviourResult.Object<Float> getExplosionResistance(Block block, BlockData blockData) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called everytime the block receives a block update due to any reason.
+     * Normally this happens when a block next to this block was changed. If you want to implement any custom behaviour on environmental changes use this method.
+     *
+     * @param location           The location of the block
+     * @param blockData          The blockData of the block
+     * @param direction          The direction of the Blockupdate
+     * @param neighbourBlockData The neighbour blockdata that issued the block update
+     * @param neighbourLocation  The neighbour location
+     * @return The blockdata that results from this update.
+     */
+    default BehaviourResult.Object<BlockData> blockUpdate(Location location, BlockData blockData, BlockFace direction, BlockData neighbourBlockData, Location neighbourLocation) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called everytime the block recognizes a neighbour block update
+     * Normally this happens when a block next to this block was changed. If you want to implement any custom behaviour on environmental changes use this method.
+     *
+     * @param block           The block recognizing the neighbour update
+     * @param sourceBlock     The neighbour block receiving the block update
+     * @param notify          The Notify flag
+     */
+    default BehaviourResult.Void onNeighbourBlockUpdate(Block block, Block sourceBlock, boolean notify) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called whenever an entity steps on a block
+     *
+     * @param block     The block
+     * @param blockData The blockData of the block
+     * @param entity    The Entity stepping on the block
+     * @return void result
+     */
+    default BehaviourResult.Void stepOn(Block block, BlockData blockData, Entity entity) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called every time the server software tries to randomly tick a block.
+     *
+     * @param block               The randomly ticked block
+     * @param vanillaRandomSource The vanilla random source
+     */
+    default BehaviourResult.Void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called to check if a blockdata is randomly ticking regardless of it being placed in a world right now.
+     *
+     * @param blockData The block data of the block
+     * @return A boolean result
+     */
+    default BehaviourResult.Bool isBlockDataRandomlyTicking(BlockData blockData) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called to check if a block in a world is randomly ticking
+     *
+     * @param block     The block
+     * @param blockData The block data of the block
+     * @return A boolean result
+     */
+    default BehaviourResult.Bool isBlockRandomlyTicking(Block block, BlockData blockData) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after the server placed a block due to any reason
+     *
+     * @param location     The location
+     * @param newBlockData The new block data
+     * @param oldBlockData The old block data
+     * @param notify       Whether this notifies the world
+     * @return callback
+     */
+    default BehaviourResult.Callback onPlace(Location location, BlockData newBlockData, BlockData oldBlockData, boolean notify) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after a player placed a block
+     *
+     * @param player   The player
+     * @param location The location
+     * @return callback
+     */
+    default BehaviourResult.Callback onPlayerPlace(Player player, Location location, BlockData thePlacedState) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after a player breaks a block
+     *
+     * @param player      The player
+     * @param location    The location
+     * @param brokenState The broken block state
+     * @return callback
+     */
+    default BehaviourResult.Callback onPlayerBreak(Player player, Location location, BlockData brokenState) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+
+    /**
+     * This callback is run after the server removes a block due to any reason
+     *
+     * @param location     The location
+     * @param newBlockData The new block data
+     * @param oldBlockData The old block data
+     * @param moved        Whether the block was moved
+     * @return callback
+     */
+    default BehaviourResult.Callback onRemove(Location location, BlockData newBlockData, BlockData oldBlockData, boolean moved) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after a player interacted with this block. This method is not run on blocks that call bukkit events! Only on those that do not define any specific onUse Behaviour
+     *
+     * @param block          The block
+     * @param player         The player
+     * @param hand           The Hand used to interact
+     * @param rayTraceResult The interaction info
+     * @return callback
+     */
+    default BehaviourResult.Callback onUse(Block block, Player player, EquipmentSlot hand, RayTraceResult rayTraceResult) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is run when a player interacts with a block in any way.
+     *
+     * @param block          The block
+     * @param player         The player
+     * @param hand           The Hand used to interact
+     * @param rayTraceResult The interaction info
+     * @return The result of this interaction
+     */
+    default BehaviourResult.Object<InteractionResult> use(Block block, Player player, EquipmentSlot hand, RayTraceResult rayTraceResult){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called every time the server software ticks a block.
+     * <p>
+     * Some blocks may not be ticked in vanilla by default. For example Stone blocks don't receive ticks.
+     * Please use the blockUpdate method to implement any custom logic or to call this method.
+     *
+     * @param block               The ticked block
+     * @param vanillaRandomSource The vanilla random source
+     */
+    default BehaviourResult.Void tick(Block block, VanillaRandomSource vanillaRandomSource) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called to check if a block can survive in the current environment
+     * <p>
+     * Some blocks may not use this method by default.
+     * Please use the blockUpdate method to implement any custom logic or to call this method.
+     *
+     * @param block The block
+     * @param world The world
+     * @return A boolean result
+     */
+    default BehaviourResult.Bool canSurvive(Block block, World world) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called every time a user left-clicks a block.
+     * <p>
+     *
+     * @param block  The clicked block
+     * @param player The player
+     */
+    default BehaviourResult.Void attack(Block block, Player player) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..e8b46b386039b456d9a955309a37b0e806b90cda
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviour.java
@@ -0,0 +1,69 @@
+package de.verdox.mccreativelab.behaviour;
+
+import de.verdox.mccreativelab.InteractionResult;
+import de.verdox.mccreativelab.MultiCustomBehaviour;
+import de.verdox.mccreativelab.recipe.CustomItemData;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.entity.Item;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.FoodProperties;
+import org.bukkit.inventory.ItemStack;
+
+public interface ItemBehaviour {
+    MultiCustomBehaviour<CustomItemData, ItemBehaviour> ITEM_BEHAVIOUR = new MultiCustomBehaviour<>("MCCLab - ItemBehaviour");
+
+    default BehaviourResult.Object<ItemStack> finishUsingItem(LivingEntity livingEntity, ItemStack usedItem){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Object<Integer> getMaxStackSize(ItemStack stack){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Object<Integer> getMaxDamage(ItemStack stack){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Bool mineBlock(ItemStack stack, Block block, Player miner){
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Bool isCorrectToolForDrops(ItemStack stack, BlockData blockData){
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Void onCraftedBy(ItemStack stack, Player player, int amount){
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Void onDestroyed(ItemStack stack, Item item){
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Bool isEdible(ItemStack stack){
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Object<InteractionResult> interactLivingEntity(ItemStack stack, Player player, LivingEntity livingEntity, EquipmentSlot equipmentSlot){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Object<FoodProperties> getFoodProperties(ItemStack stack){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Object<ItemStack> getCraftRemainingItem(ItemStack stack){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Bool isFireResistant(ItemStack stack){
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Bool canFitInsideContainerItems(ItemStack stack){
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/RandomTickBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/RandomTickBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..28db22a347fdccbfb23aefd8696cd187a9e68c02
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/RandomTickBehaviour.java
@@ -0,0 +1,24 @@
+package de.verdox.mccreativelab.behaviour;
+
+import de.verdox.mccreativelab.MultiCustomBehaviour;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.Material;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.BlockData;
+
+@Deprecated
+public interface RandomTickBehaviour {
+    MultiCustomBehaviour<Material, RandomTickBehaviour> RANDOM_TICK_BEHAVIOUR = new MultiCustomBehaviour<>("MCCLab - RandomTickBehaviour");
+    /**
+     * This method is called every time the server software checks whether a particular blockdata is randomly ticking.
+     * @param blockData The Blockdata
+     * @return true if the block is a valid bonemeal target
+     */
+    boolean isRandomlyTicking(BlockData blockData);
+    /**
+     * This method is called every time the server software tries to randomly tick a block.
+     * @param block The randomly ticked block
+     * @param vanillaRandomSource The vanilla random source
+     */
+    void randomTick(Block block, VanillaRandomSource vanillaRandomSource);
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaBambooSaplingBlock.java b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaBambooSaplingBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..85860c91897a8c37e763c15a3b24ff0fc4806659
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaBambooSaplingBlock.java
@@ -0,0 +1,18 @@
+package de.verdox.mccreativelab.behaviour.randomtick;
+
+import de.verdox.mccreativelab.behaviour.RandomTickBehaviour;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.BlockData;
+
+public class VanillaBambooSaplingBlock implements RandomTickBehaviour {
+    @Override
+    public boolean isRandomlyTicking(BlockData blockData) {
+        return false;
+    }
+
+    @Override
+    public void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaCropBlockRandomTick.java b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaCropBlockRandomTick.java
new file mode 100644
index 0000000000000000000000000000000000000000..73a11f2212bbb1a98d76840fca2bdb38135989a2
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaCropBlockRandomTick.java
@@ -0,0 +1,160 @@
+package de.verdox.mccreativelab.behaviour.randomtick;
+
+import de.verdox.mccreativelab.behaviour.RandomTickBehaviour;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockState;
+import org.bukkit.block.data.Ageable;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.block.data.type.Farmland;
+import org.bukkit.event.block.BlockGrowEvent;
+
+import java.util.concurrent.ThreadLocalRandom;
+
+public class VanillaCropBlockRandomTick implements RandomTickBehaviour {
+    @Override
+    public void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+        var lightLevel = block.getLightLevel();
+        if (lightLevel < 9)
+            return;
+
+        Ageable ageable = (Ageable) block.getBlockData();
+        var age = ageable.getAge();
+
+        if (age < ageable.getMaximumAge()) {
+            float growthSpeed = calculateCropGrowthSpeed(block);
+
+            int modifier;
+            if (block.getType().equals(Material.BEETROOT))
+                modifier = getAndValidateGrowth("Beetroot");
+            else if (block.getType().equals(Material.CARROT))
+                modifier = getAndValidateGrowth("Carrot");
+            else if (block.getType().equals(Material.POTATO))
+                modifier = getAndValidateGrowth("Potato");
+            else if (block.getType().equals(Material.TORCHFLOWER_CROP))
+                modifier = getAndValidateGrowth("TorchFlower");
+            else
+                modifier = getAndValidateGrowth("Wheat");
+
+            var randomNumber = drawRandomNumber();
+
+            if(canGrow(block, growthSpeed, modifier, randomNumber)){
+                ageUpAndCallBlockGrowEvent(block, ageable);
+            }
+        }
+    }
+
+    protected void ageUpAndCallBlockGrowEvent(Block block, Ageable ageable) {
+        var stateSnapshot = block.getState();
+        ageable.setAge(Math.min(ageable.getMaximumAge(), ageable.getAge() + 1));
+        stateSnapshot.setBlockData(ageable);
+        handleBlockGrowEvent(block, stateSnapshot);
+    }
+
+    protected boolean handleBlockGrowEvent(Block block, BlockState newBlockState){
+        BlockGrowEvent event = new BlockGrowEvent(block, newBlockState);
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (!event.isCancelled()) {
+            block.setBlockData(newBlockState.getBlockData());
+        }
+        return !event.isCancelled();
+    }
+
+    protected boolean handleBlockGrowEvent(Block block, BlockData blockData){
+        var blockState = block.getState(true);
+        blockState.setBlockData(blockData);
+        return handleBlockGrowEvent(block, blockState);
+    }
+
+    protected float drawRandomNumber(){
+        return ThreadLocalRandom.current().nextFloat();
+    }
+
+    @Override
+    public boolean isRandomlyTicking(BlockData blockData) {
+        if(!(blockData instanceof Ageable ageable))
+            return false;
+        return ageable.getAge() < ageable.getMaximumAge();
+    }
+
+    protected boolean canGrow(Block block, float growthSpeed, float spigotConfigModifier, float minecraftRandomNumber){
+        return minecraftRandomNumber < (spigotConfigModifier / (100.0f * (Math.floor((25.0F / growthSpeed) + 1))));
+    }
+
+    protected float calculateCropGrowthSpeed(Block block) {
+        float growthSpeed = 1.0F;
+        var pos = block.getLocation();
+        var world = block.getWorld();
+        var farmLandPos = pos.getBlock().getRelative(BlockFace.DOWN).getLocation();
+
+        for (int i = -1; i <= 1; ++i) {
+            for (int j = -1; j <= 1; ++j) {
+                float tempGrowthSpeedValueThisBlock = 0.0F;
+                var blockState = world.getBlockState(farmLandPos.clone().add(i, 0, j));
+
+                if (blockState.getType().equals(Material.FARMLAND)) {
+                    var farmLand = ((Farmland) blockState.getBlockData());
+                    tempGrowthSpeedValueThisBlock = calculateGrowthSpeedValueBasedOnFarmland(farmLand);
+                }
+
+                if (i != 0 || j != 0)
+                    tempGrowthSpeedValueThisBlock /= 4.0F;
+
+
+                growthSpeed += tempGrowthSpeedValueThisBlock;
+            }
+        }
+
+        var northBlockPos = getRelative(pos, BlockFace.NORTH);
+        var southBlockPos = getRelative(pos, BlockFace.SOUTH);
+        var westBlockPos = getRelative(pos, BlockFace.WEST);
+        var eastBlockPos = getRelative(pos, BlockFace.EAST);
+        boolean westOrEastSameCrop = isSameCrop(block, westBlockPos) || isSameCrop(block, eastBlockPos);
+        boolean northOrWestSameCrop = isSameCrop(block, northBlockPos) || isSameCrop(block, southBlockPos);
+
+        if (westOrEastSameCrop && northOrWestSameCrop)
+            growthSpeed /= 2.0F;
+        else {
+            boolean sameCropDiagonal =
+                isSameCrop(block, getRelative(westBlockPos, BlockFace.NORTH))
+                    || isSameCrop(block, getRelative(eastBlockPos, BlockFace.NORTH))
+                    || isSameCrop(block, getRelative(eastBlockPos, BlockFace.SOUTH))
+                    || isSameCrop(block, getRelative(westBlockPos, BlockFace.SOUTH));
+
+            if (sameCropDiagonal)
+                growthSpeed /= 2.0F;
+        }
+
+        return growthSpeed;
+    }
+
+    protected float calculateGrowthSpeedValueBasedOnFarmland(Farmland farmLand) {
+        float tempGrowthSpeedValueThisBlock;
+        tempGrowthSpeedValueThisBlock = 1.0F;
+        if (farmLand.getMoisture() > 0) {
+            tempGrowthSpeedValueThisBlock = 3.0F;
+        }
+        return tempGrowthSpeedValueThisBlock;
+    }
+
+    protected final Location getRelative(Location location, BlockFace face) {
+        return location.getBlock().getRelative(face).getLocation();
+    }
+
+    protected final int getAndValidateGrowth(String crop) {
+        var config = Bukkit.spigot().getSpigotConfig();
+        int modifier = config.getInt("growth." + crop.toLowerCase(java.util.Locale.ENGLISH) + "-modifier", 100);
+        if (modifier == 0)
+            modifier = 100;
+        return modifier;
+    }
+
+    protected boolean isSameCrop(Block block, Location relativePos) {
+        return block.getWorld().getBlockState(relativePos).getType().equals(block.getType());
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaFarmBlockTickBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaFarmBlockTickBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e02cb17beeb341d99ba79ed61f71272fc41cc28
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaFarmBlockTickBehaviour.java
@@ -0,0 +1,103 @@
+package de.verdox.mccreativelab.behaviour.randomtick;
+
+import de.verdox.mccreativelab.behaviour.RandomTickBehaviour;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.Bukkit;
+import org.bukkit.GameEvent;
+import org.bukkit.Material;
+import org.bukkit.Tag;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.block.data.type.Farmland;
+import org.bukkit.event.block.BlockFadeEvent;
+import org.bukkit.event.block.MoistureChangeEvent;
+import org.bukkit.util.BlockVector;
+
+public class VanillaFarmBlockTickBehaviour implements RandomTickBehaviour {
+    private static int FARMLAND_WATER_RADIUS = 4;
+
+    @Override
+    public void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+        Farmland farmlandData = (Farmland) block.getBlockData();
+        int moisture = farmlandData.getMoisture();
+
+        if (isNearWater(block, FARMLAND_WATER_RADIUS) || block.getWorld()
+                                                              .isRainingAt(above(block).getLocation())) {
+            if (moisture >= 7)
+                return;
+            handleMoistureChangeEvent(block, 7);
+            return;
+        }
+
+        if (moisture > 0)
+            handleMoistureChangeEvent(block, moisture - 1);
+        else if (!shouldMaintainFarmland(block))
+            turnToDirt(block);
+    }
+
+    @Override
+    public boolean isRandomlyTicking(BlockData blockData) {
+        return true;
+    }
+
+    private static boolean shouldMaintainFarmland(Block block) {
+        return Tag.MAINTAINS_FARMLAND.isTagged(above(block).getType());
+    }
+
+    private static Block above(Block block) {
+        return block.getRelative(0, 1, 0);
+    }
+
+    private static boolean isNearWater(Block block, int horizontalRadius) {
+        int xOff = block.getX();
+        int yOff = block.getY();
+        int zOff = block.getZ();
+
+        for (int dz = -horizontalRadius; dz <= horizontalRadius; ++dz) {
+            int z = dz + zOff;
+            for (int dx = -horizontalRadius; dx <= horizontalRadius; ++dx) {
+                int x = xOff + dx;
+                for (int dy = 0; dy <= 1; ++dy) {
+                    int y = dy + yOff;
+                    Block nearBlock = block.getWorld().getBlockAt(x, y, z);
+                    if (nearBlock.getType().equals(Material.WATER))
+                        return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    private static boolean handleMoistureChangeEvent(Block block, int newMoistureLevel) {
+        Farmland farmland = (Farmland) block.getBlockData();
+        if (newMoistureLevel == farmland.getMoisture() || newMoistureLevel > farmland.getMaximumMoisture())
+            return false;
+
+        farmland.setMoisture(newMoistureLevel);
+        var newState = block.getState();
+        newState.setBlockData(farmland);
+
+        MoistureChangeEvent event = new MoistureChangeEvent(block, newState);
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (!event.isCancelled()) {
+            block.setBlockData(newState.getBlockData());
+        }
+        return !event.isCancelled();
+    }
+
+    private static void turnToDirt(Block block){
+        BlockState newState = block.getState();
+        newState.setType(Material.DIRT);
+
+        BlockFadeEvent event = new BlockFadeEvent(block, newState);
+        Bukkit.getPluginManager().callEvent(event);
+        if(event.isCancelled())
+            return;
+
+        block.setType(Material.DIRT, true);
+        block.getWorld().sendGameEvent(null, GameEvent.BLOCK_CHANGE, new BlockVector(block.getX(), block.getY(), block.getZ()));
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaSaplingBlockBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaSaplingBlockBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c9175bf3fdbd9893c29ecfab5ea31e2f247f1fb
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaSaplingBlockBehaviour.java
@@ -0,0 +1,28 @@
+package de.verdox.mccreativelab.behaviour.randomtick;
+
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.block.data.type.Sapling;
+
+public class VanillaSaplingBlockBehaviour extends VanillaCropBlockRandomTick {
+    @Override
+    public void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+        if(block.getLightLevel() >= 9 && drawRandomNumber() < (getAndValidateGrowth("Sapling") / (100.0f * 7))){
+            var sapling = (Sapling) block.getBlockData();
+            var stage = sapling.getStage();
+            if(stage == 0){
+                sapling.setStage(1);
+                handleBlockGrowEvent(block, sapling);
+            }
+            else {
+                block.getWorld().growTreeIfSapling(block.getLocation());
+            }
+        }
+    }
+
+    @Override
+    public boolean isRandomlyTicking(BlockData blockData) {
+        return true;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaStemBlockBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaStemBlockBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..448eecfb9cbfa8db18d20a1333705f19e345c018
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaStemBlockBehaviour.java
@@ -0,0 +1,71 @@
+package de.verdox.mccreativelab.behaviour.randomtick;
+
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.data.Ageable;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.block.data.Directional;
+
+import java.util.concurrent.ThreadLocalRandom;
+
+public class VanillaStemBlockBehaviour extends VanillaCropBlockRandomTick {
+    public static BlockFace[] HORIZONTAL_PLANE = new BlockFace[]{BlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST, BlockFace.WEST};
+
+    @Override
+    public void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+        var lightLevel = block.getLightLevel();
+        if (lightLevel < 9)
+            return;
+
+        float growthSpeed = calculateCropGrowthSpeed(block);
+        var randomNumber = drawRandomNumber();
+
+        int modifier;
+        Material fruit;
+        Material attachedStem;
+        if (block.getType().equals(Material.PUMPKIN_STEM)) {
+            modifier = getAndValidateGrowth("Pumpkin");
+            fruit = Material.PUMPKIN;
+            attachedStem = Material.ATTACHED_PUMPKIN_STEM;
+        }
+        else {
+            modifier = getAndValidateGrowth("Melon");
+            fruit = Material.MELON;
+            attachedStem = Material.ATTACHED_MELON_STEM;
+        }
+
+        if (randomNumber >= (modifier) / (100.0f * (Math.floor((25.0F / growthSpeed) + 1))))
+            return;
+
+        var ageable = (Ageable) block.getBlockData();
+        var age = ageable.getAge();
+        var maxAge = ageable.getMaximumAge();
+
+        if (age < maxAge) {
+            ageUpAndCallBlockGrowEvent(block, ageable);
+            return;
+        }
+        var randomBlockFace = HORIZONTAL_PLANE[ThreadLocalRandom.current().nextInt(HORIZONTAL_PLANE.length)];
+        var relativeBlockPos = getRelative(block.getLocation(), randomBlockFace);
+        var relativeBlock = relativeBlockPos.getBlock();
+        var belowRelativPos = relativeBlock.getRelative(0, -1, 0);
+
+        if (belowRelativPos.getType().isAir() && (relativeBlock.getType().equals(Material.FARMLAND) || relativeBlock
+            .getType().equals(Material.DIRT))) {
+
+            if(!handleBlockGrowEvent(relativeBlock, Bukkit.createBlockData(fruit)))
+                return;
+
+            var stemBlockData = Bukkit.createBlockData(attachedStem, blockData -> ((Directional) blockData).setFacing(randomBlockFace));
+            block.setBlockData(stemBlockData, true);
+        }
+    }
+
+    @Override
+    public boolean isRandomlyTicking(BlockData blockData) {
+        return true;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaSugarCaneBlockBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaSugarCaneBlockBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7615978914b2d9f306cebd54207a06c5b85a7f6
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/randomtick/VanillaSugarCaneBlockBehaviour.java
@@ -0,0 +1,42 @@
+package de.verdox.mccreativelab.behaviour.randomtick;
+
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.Ageable;
+import org.bukkit.block.data.BlockData;
+
+public class VanillaSugarCaneBlockBehaviour extends VanillaCropBlockRandomTick {
+    @Override
+    public void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+        if (!block.getRelative(0, 1, 0).getType().isAir())
+            return;
+        var heightCounter = 0;
+        for(heightCounter = 1; block.getRelative(0, heightCounter,0).getType().equals(Material.SUGAR_CANE); heightCounter++){
+            ;
+        }
+        var modifier = getAndValidateGrowth("Cane");
+        var ageable = (Ageable) block.getBlockData();
+        var age = ageable.getAge();
+        var maxAge = ageable.getMaximumAge();
+
+        if(heightCounter < 3){
+
+            if(age >= 15 || (modifier != 100 && drawRandomNumber() < (modifier / (100f * 16)))){
+                handleBlockGrowEvent(block.getRelative(0,1,0), Bukkit.createBlockData(Material.SUGAR_CANE));
+                ageable.setAge(0);
+                block.setBlockData(ageable);
+            }
+            else if(modifier == 100 || drawRandomNumber() < (modifier / (100.0f * 16))){
+                ageable.setAge(Math.min(maxAge, ageable.getAge() + 1));
+                block.setBlockData(ageable);
+            }
+        }
+    }
+
+    @Override
+    public boolean isRandomlyTicking(BlockData blockData) {
+        return true;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/event/world/WorldEffectEvent.java b/src/main/java/io/papermc/paper/event/world/WorldEffectEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e7964834937d16003314cdbd2c424cd77cf1a41
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/world/WorldEffectEvent.java
@@ -0,0 +1,134 @@
+package io.papermc.paper.event.world;
+
+import org.bukkit.Effect;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.world.WorldEvent;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class WorldEffectEvent extends WorldEvent implements Cancellable {
+    private static final HandlerList HANDLER_LIST = new HandlerList();
+    private final boolean global;
+    private Location soundLocation;
+    private Player except;
+    private Effect effect;
+    private int data;
+    private boolean cancelled;
+
+    public WorldEffectEvent(@NotNull World world, @NotNull Location soundLocation, @Nullable Player except, Effect effect, int data, boolean global) {
+        super(world);
+        this.soundLocation = soundLocation;
+        this.except = except;
+        this.effect = effect;
+        this.data = data;
+        this.global = global;
+    }
+
+    /**
+     * Sets the location of the effect
+     *
+     * @param soundLocation - The new location
+     */
+    public void setSoundLocation(Location soundLocation) {
+        this.soundLocation = soundLocation;
+    }
+
+    /**
+     * Sets the player to except from receiving this effect
+     *
+     * @param except - The excepted player
+     */
+    public void setExcept(Player except) {
+        this.except = except;
+    }
+
+    /**
+     * Sets the effect played
+     *
+     * @param effect - The new effect
+     */
+    public void setEffect(Effect effect) {
+        this.effect = effect;
+    }
+
+    /**
+     * Sets the data associated with this effect
+     *
+     * @param data - the new data
+     */
+    public void setData(int data) {
+        this.data = data;
+    }
+
+    /**
+     * Gets if the world effect is global
+     *
+     * @return - true if global
+     */
+    public boolean isGlobal() {
+        return global;
+    }
+
+    /**
+     * Gets the location of the effect origin
+     *
+     * @return - The location
+     */
+    public Location getSoundLocation() {
+        return soundLocation;
+    }
+
+    /**
+     * Gets the except player if available.
+     * This is not null for effects that occur on client side simultaneously.
+     *
+     * @return - The except player if available
+     */
+    @Nullable
+    public Player getExcept() {
+        return except;
+    }
+
+    /**
+     * The effect associated with this event
+     *
+     * @return - The effect
+     */
+    public Effect getEffect() {
+        return effect;
+    }
+
+    /**
+     * The data associated with this effect
+     * See <a href="https://wiki.vg/Protocol#:~:text=been%20highly%20inconsistent.-,World%20Event,-Sent%20when%20a">...</a> for further details
+     *
+     * @return - The data
+     */
+    public int getData() {
+        return data;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return HANDLER_LIST;
+    }
+
+    @NotNull
+    public HandlerList getHandlers() {
+        return HANDLER_LIST;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/event/world/WorldSoundEvent.java b/src/main/java/io/papermc/paper/event/world/WorldSoundEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..9adfd51f6659e920786658c34709ee5d1b0f790a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/world/WorldSoundEvent.java
@@ -0,0 +1,202 @@
+package io.papermc.paper.event.world;
+
+import net.kyori.adventure.sound.Sound;
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.World;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.world.WorldEvent;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+/**
+ * Is called when a sound is played in a world.
+ * Some sounds are client side and can't be manipulated with this event.
+ */
+public class WorldSoundEvent extends WorldEvent implements Cancellable {
+    private static final HandlerList HANDLER_LIST = new HandlerList();
+    private Location soundLocation;
+    private @Nullable Player except;
+    private @Nullable Entity emitter;
+    private NamespacedKey sound;
+    private Sound.Source soundCategory;
+    private float volume;
+    private float pitch;
+    private long seed;
+    private boolean cancelled;
+
+    public WorldSoundEvent(@NotNull World world, @NotNull Location soundLocation, @Nullable Player except, @Nullable Entity emitter, @NotNull NamespacedKey sound, @NotNull Sound.Source soundCategory, float volume, float pitch, long seed) {
+        super(world);
+        this.soundLocation = soundLocation;
+        this.except = except;
+        this.emitter = emitter;
+        this.sound = sound;
+        this.soundCategory = soundCategory;
+        this.volume = volume;
+        this.pitch = pitch;
+        this.seed = seed;
+    }
+
+    /**
+     * Sets the location of the sound
+     * If the sound has an emitter entity the location will be the location of the entity
+     * @param soundLocation - The new sound location
+     */
+    public void setSoundLocation(@NotNull Location soundLocation) {
+        Objects.requireNonNull(soundLocation);
+        this.soundLocation = soundLocation;
+    }
+
+    /**
+     * Sets the emitter of this sound event.
+     * If the emitter is null, the soundLocation will be used instead
+     * @param emitter - The new entity emitter
+     */
+    public void setEmitter(@Nullable Entity emitter) {
+        this.emitter = emitter;
+    }
+
+    /**
+     * Sets the player that is excepted from this sound event
+     * @param except - The Player excepted
+     */
+    public void setExcept(@Nullable Player except) {
+        this.except = except;
+    }
+
+    /**
+     * Sets the sound played by this event
+     * @param sound - The sound
+     */
+    public void setSound(@NotNull NamespacedKey sound) {
+        Objects.requireNonNull(sound);
+        this.sound = sound;
+    }
+
+    /**
+     * Sets the volume of the sound
+     * @param volume - The volume
+     */
+    public void setVolume(float volume) {
+        this.volume = volume;
+    }
+
+    /**
+     * Sets the pitch of the sound
+     * @param pitch - The pitch
+     */
+    public void setPitch(float pitch) {
+        this.pitch = pitch;
+    }
+
+    /**
+     * Sets the sound category of this sound
+     * @param soundCategory - The sound category
+     */
+    public void setSoundCategory(@NotNull Sound.Source soundCategory) {
+        Objects.requireNonNull(soundCategory);
+        this.soundCategory = soundCategory;
+    }
+
+    /**
+     * Sets the sound seed
+     * @param seed - The seed
+     */
+    public void setSeed(long seed) {
+        this.seed = seed;
+    }
+
+    /**
+     * Gets the player that is excepted from this sound event.
+     * This is used to play player related sounds the client produces as well to prevent double sounds.
+     * Is null when the sound has no player that wont receive it
+     * @return The player if available
+     */
+    @Nullable
+    public Player getExcept() {
+        return except;
+    }
+
+    /**
+     * Gets the sound related to this event
+     * @return - The sound
+     */
+    @NotNull
+    public NamespacedKey getSound() {
+        return sound;
+    }
+
+    /**
+     * Gets the sound category of this sound
+     * @return - The sound category
+     */
+    @NotNull
+    public Sound.Source getSoundCategory() {
+        return soundCategory;
+    }
+
+    /**
+     * Gets the volume
+     * @return - The volume
+     */
+    public float getVolume() {
+        return volume;
+    }
+
+    /**
+     * Gets the emitter of the sound.
+     * Might be null if the sound origin is not an entity
+     * @return - The sound emitter
+     */
+    public @Nullable Entity getEmitter() {
+        return emitter;
+    }
+
+    /**
+     * Gets the location of the sound
+     * @return - The sound location
+     */
+    public Location getSoundLocation() {
+        return soundLocation;
+    }
+
+    /**
+     * Gets the pitch
+     * @return - The pitch
+     */
+    public float getPitch() {
+        return pitch;
+    }
+
+    /**
+     * Gets the sound seed
+     * @return - The seed
+     */
+    public long getSeed() {
+        return seed;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return HANDLER_LIST;
+    }
+    @NotNull
+    public HandlerList getHandlers() {
+        return HANDLER_LIST;
+    }
+}
diff --git a/src/main/java/org/bukkit/entity/Player.java b/src/main/java/org/bukkit/entity/Player.java
index 20fa1024f9ad8f478a347be5c554b5e45b398a1c..9570c7de760f0c15a49237b0960d7bbf2b135c69 100644
--- a/src/main/java/org/bukkit/entity/Player.java
+++ b/src/main/java/org/bukkit/entity/Player.java
@@ -39,6 +39,7 @@ import org.bukkit.event.player.PlayerExpCooldownChangeEvent;
 import org.bukkit.event.player.PlayerResourcePackStatusEvent;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.PlayerInventory;
 import org.bukkit.map.MapView;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.PluginMessageRecipient;
@@ -679,6 +680,25 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
     @Deprecated
     public void playEffect(@NotNull Location loc, @NotNull Effect effect, int data);
 
+    // MCCLab start
+    /**
+     * Whether the player inventory synchronizer should be used.
+     * If set to false the player will not send container or inventory changes to the player.
+     * This is useful to send a fake inventory to the player if needed.
+     * @param value - The new value
+     * @return
+     */
+    void doInventorySynchronization(boolean value);
+    // MCCLab end
+
+    void sendFakeInventoryContents(ItemStack[] fakeContents);
+
+    /**
+     * Returns true if the inventory synchronizer of the player is working currently
+     * @return - true if the synchronizer is working
+     */
+    boolean isInventorySynchronization();
+
     /**
      * Plays an effect to just this player.
      *
diff --git a/src/main/java/org/bukkit/inventory/FoodProperties.java b/src/main/java/org/bukkit/inventory/FoodProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f141daee39ac344774b73856cbc09fd35c319eb
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/FoodProperties.java
@@ -0,0 +1,15 @@
+package org.bukkit.inventory;
+
+import it.unimi.dsi.fastutil.Pair;
+import org.bukkit.potion.PotionEffect;
+
+import java.util.List;
+
+public interface FoodProperties {
+    int getNutrition();
+    float getSaturationModifier();
+    boolean isMeat();
+    boolean canAlwaysEat();
+    boolean isFastFood();
+    List<Pair<PotionEffect, Float>> getEffects();
+}
