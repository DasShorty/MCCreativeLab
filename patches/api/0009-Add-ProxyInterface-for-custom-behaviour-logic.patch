From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: derverdox <mail.ysp@web.de>
Date: Thu, 18 Jan 2024 16:18:57 +0100
Subject: [PATCH] Add ProxyInterface for custom behaviour logic


diff --git a/src/main/java/de/verdox/mccreativelab/ProxyInterface.java b/src/main/java/de/verdox/mccreativelab/ProxyInterface.java
new file mode 100644
index 0000000000000000000000000000000000000000..cfd8c904e47b8c8739abebce431c7f8934367797
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/ProxyInterface.java
@@ -0,0 +1,84 @@
+package de.verdox.mccreativelab;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.BiFunction;
+
+/**
+ * A proxy interface provider that merges various implementations of the same interface to one proxy instance.
+ * @param <T>
+ */
+public class ProxyInterface<T> {
+    private final Map<Method, T> methodToImplementationCache = new HashMap<>();
+    private final Class<? extends T> type;
+    private final T defaultImplementation;
+    private final T proxy;
+
+    public ProxyInterface(Class<? extends T> type, T defaultImplementation){
+        this.type = type;
+        this.defaultImplementation = defaultImplementation;
+        this.proxy = createProxy();
+    }
+
+    public T getImplementation(){
+        return this.proxy;
+    }
+
+    public void addImplementation(T implementation, BiFunction<T,Method,Boolean> replaceExistingMethodImplementation){
+        for (Method declaredMethod : implementation.getClass().getMethods()) {
+            Method overridenMethod = getOverriddenMethod(declaredMethod);
+            if(overridenMethod == null)
+                continue;
+            if(methodToImplementationCache.containsKey(overridenMethod) && (replaceExistingMethodImplementation == null || !replaceExistingMethodImplementation.apply(methodToImplementationCache.get(overridenMethod), overridenMethod))){
+                System.err.println("Method "+overridenMethod+" already implemented");
+                continue;
+            }
+            methodToImplementationCache.put(overridenMethod, implementation);
+        }
+    }
+
+    public boolean isImplemented(){
+        return !methodToImplementationCache.isEmpty();
+    }
+
+    public void addImplementation(T implementation){
+        addImplementation(implementation, null);
+    }
+
+    private T createProxy(){
+        return type.cast(Proxy.newProxyInstance(
+            type.getClassLoader(),
+            new Class<?>[]{type},
+            (proxy, method, args) -> {
+
+                T implementation = defaultImplementation;
+
+                if(methodToImplementationCache.containsKey(method))
+                    implementation = methodToImplementationCache.get(method);
+
+                return method.invoke(implementation, args);
+            }
+        ));
+    }
+
+    private Method getOverriddenMethod(final Method myMethod) {
+        Class<?> declaringClass = myMethod.getDeclaringClass();
+        if (declaringClass.equals(Object.class) || declaringClass.getSuperclass() == null) {
+            return null;
+        }
+        try {
+            return declaringClass.getSuperclass().getMethod(myMethod.getName(), myMethod.getParameterTypes());
+        } catch (NoSuchMethodException e) {
+            for (Class<?> iface : declaringClass.getInterfaces()) {
+                try {
+                    return iface.getMethod(myMethod.getName(), myMethod.getParameterTypes());
+                } catch (NoSuchMethodException ignored) {
+
+                }
+            }
+            return null;
+        }
+    }
+}
